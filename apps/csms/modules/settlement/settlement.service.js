const { DateTime } = require("luxon");
const {
  SettlementRepository,
  SettlementPartnerRepository,
  SettlementViewRepository,
  ContractPartnersRepository,
  OcppTransactionsRepository,
  ChargerRevenueRepository,
  PartnerRepository,
  UserRepository,
  ContractViewRepository,
  ContractEvseStationsRepository,
} = require("@shared-libs/db/mysql");
const { HandleMySqlList } = require("@shared-libs/db");
const {
  ObjectDAO,
  getSettlementCode,
  getTimezoneByCountry,
  convertDateTimezone,
  arrayObjStr,
  getTrendsData,
} = require("@shared-libs/helpers");
const {
  SettlementStatuses,
  TransferStatuses,
} = require("@shared-libs/constants");
const { In, Between } = require("typeorm");
const { formatDateString } = require("@shared-libs/helpers");

const calculatePartnerShare = (settlementAmount, splitPercentage) => {
  return (settlementAmount * splitPercentage) / 100;
};

const addSettlement = async (req, res) => {
  return res.status(400).json({
    message: "Settlement can be only generated by CRON.",
  });
  try {
    const {
      settlementId,
      settlementPeriod,
      settlementDate,
      settlementDateLocal,
      contractId,
      emspId,
      numberOfTransactions,
      settlementAmount,
      paymentGateway,
      status,
      invoicePdf,
      timezone,
      createdAt,
      updatedAt,
      createdAtLocal,
      updatedAtLocal,
    } = req.body;

    const settlement = await SettlementRepository.create({
      settlementId,
      settlementPeriod,
      settlementDate,
      settlementDateLocal,
      contractId,
      emspId,
      numberOfTransactions,
      settlementAmount,
      paymentGateway,
      status,
      invoicePdf,
      timezone,
      createdAt,
      updatedAt,
      createdAtLocal,
      updatedAtLocal,
    });

    // Save the settlement first
    const savedSettlement = await SettlementRepository.save(settlement);

    // Fetch contract partners data
    const contractPartners = await ContractPartnersRepository.find({
      where: { contractId: contractId, isDeleted: false },
    });

    if (contractPartners.length === 0) {
      return res
        .status(400)
        .json({ message: "No partners found for this contract" });
    }

    // Get partner IDs from contract partners
    const partnerIds = contractPartners.map((cp) => cp.partnerId);

    // Fetch partner details from partner table
    const partners = await PartnerRepository.find({
      where: { userId: In(partnerIds) },
    });

    // Fetch user details for email and name
    const users = await UserRepository.find({
      where: { id: In(partnerIds) },
    });

    // Create a map for easy lookup
    const userMap = new Map(users.map((user) => [user.id, user]));
    const contractPartnerMap = new Map(
      contractPartners.map((cp) => [cp.partnerId, cp])
    );

    // Create settlement partners
    const settlementPartnersData = partners.map((partner) => {
      const user = userMap.get(partner.userId);
      const contractPartner = contractPartnerMap.get(partner.userId);

      // Calculate partner amount based on settlement amount and split percentage
      const partnerAmount = calculatePartnerShare(
        settlementAmount,
        contractPartner.splitPercentage
      );

      return {
        settlementId: savedSettlement.id,
        partnerId: partner.userId,
        partnerName: user ? user.name : partner.companyName,
        partnerEmail: user ? user.email : partner.email,
        partnerType: contractPartner.partnerType,
        splitPercentage: contractPartner.splitPercentage,
        amount: partnerAmount,
        transferStatus: TransferStatuses.PENDING,
        transferredBy: null,
        bankName: partner.bankName,
        accountNumber: partner.accountNumber,
        timezone: partner.timezone || timezone,
        createdAt: new Date(),
        updatedAt: new Date(),
        createdAtLocal: createdAtLocal || new Date(),
        updatedAtLocal: updatedAtLocal || new Date(),
      };
    });

    // Save all settlement partners
    const savedSettlementPartners = await SettlementPartnerRepository.save(
      settlementPartnersData
    );

    res.status(200).json({
      settlement: savedSettlement,
      partners: savedSettlementPartners,
      message: "Settlement and partners created successfully",
    });
  } catch (error) {
    console.error("Error adding settlement:", error);
    res
      .status(500)
      .json({ message: "Failed to add settlement", error: error.message });
  }
};

const generateSettlement = async (req, res) => {
  const contractId = req.body?.contractId;
  const contractData = await ContractViewRepository.findOne({
    where: { id: contractId },
  });

  const partnerIds = [contractData?.cpoId, contractData?.siteHostId];
  if (contractData?.investors?.length > 0) {
    if (contractData?.investors[0]?.partnerId) {
      partnerIds.push(contractData?.investors[0]?.partnerId);
    }
    if (contractData?.investors[1]?.partnerId) {
      partnerIds.push(contractData?.investors[1]?.partnerId);
    }
  }

  let partnerData = await PartnerRepository.find({
    where: { userId: In(partnerIds) },
    select: ["userId", "bankName", "accountNumber"],
  });

  partnerData = arrayObjStr(partnerData, "userId");

  if (!contractData) {
    return res.status(400).json({
      message: "Invalid Contract ID",
    });
  }

  const settlementId = await getSettlementCode();

  const country = contractData?.country ?? "CA";

  const timezone = await getTimezoneByCountry(country);
  const createdAtLocal = convertDateTimezone(DateTime.utc(), timezone);

  let settlementDate = DateTime.utc()
    .minus({ week: 1 })
    .startOf("day")
    .toJSDate();

  // return res.status(200).json({
  //   message: "Settlement Generate successfully",
  // });

  const settlementDateLocal = convertDateTimezone(
    DateTime.fromJSDate(settlementDate, { zone: "UTC" }),
    timezone
  );

  settlementDate = convertDateTimezone(
    DateTime.fromJSDate(settlementDate, { zone: "UTC" }),
    "UTC"
  );

  let chargerRevenueData = await ChargerRevenueRepository.createQueryBuilder(
    "chargerRevenue"
  )
    .select("chargerRevenue.totalAmount", "totalAmount")
    .addSelect("chargerRevenue.id", "id")
    .where("chargerRevenue.dateTime <= :start", {
      start: settlementDate,
    })
    .andWhere("chargerRevenue.contractId = :contractId", {
      contractId,
    })
    .andWhere("chargerRevenue.isSettlementGenerated = :isSettlementGenerated", {
      isSettlementGenerated: 0,
    })
    .getRawMany();

  const numberOfTransactions = chargerRevenueData.length;
  const settlementAmount = chargerRevenueData.reduce((sum, chargerRevenue) => {
    return sum + (parseFloat(chargerRevenue.totalAmount) || 0);
  }, 0);

  let chargerRevenueIds = chargerRevenueData.map((cr) => cr.id);

  if (settlementAmount > 0) {
    const savedSettlement = await SettlementRepository.save({
      settlementId,
      settlementPeriod: "1 Week",
      settlementDate,
      settlementDateLocal,
      contractId,
      emspId: contractData?.emspId,
      numberOfTransactions,
      settlementAmount,
      paymentGateway: "moneris",
      timezone,
      createdAtLocal,
      updatedAtLocal: createdAtLocal,
    });

    if (savedSettlement?.id) {
      const settlementPartnerData = [
        {
          settlementId: savedSettlement?.id,
          partnerId: contractData?.cpoId,
          partnerName: contractData?.cpoName,
          partnerEmail: contractData?.cpoEmail,
          partnerType: "CPO",
          splitPercentage: contractData?.cpoSplitPercentage,
          amount:
            settlementAmount > 0
              ? (settlementAmount * contractData?.cpoSplitPercentage) / 100
              : 0,
          bankName: partnerData[contractData?.cpoId]?.bankName,
          accountNumber: partnerData[contractData?.cpoId]?.accountNumber,
          timezone,
          createdAtLocal,
          updatedAtLocal: createdAtLocal,
        },
        {
          settlementId: savedSettlement?.id,
          partnerId: contractData?.siteHostId,
          partnerName: contractData?.siteHostName,
          partnerEmail: contractData?.siteHostEmail,
          partnerType: "Site Host",
          splitPercentage: contractData?.siteHostSplitPercentage,
          amount:
            settlementAmount > 0
              ? (settlementAmount * contractData?.siteHostSplitPercentage) / 100
              : 0,
          bankName: partnerData[contractData?.siteHostId]?.bankName,
          accountNumber: partnerData[contractData?.siteHostId]?.accountNumber,
          timezone,
          createdAtLocal,
          updatedAtLocal: createdAtLocal,
        },
      ];

      if (contractData?.investors?.length > 0) {
        if (contractData?.investors[0]?.partnerId) {
          settlementPartnerData.push({
            settlementId: savedSettlement?.id,
            partnerId: contractData?.investors[0]?.partnerId,
            partnerName: contractData?.investors[0]?.partnerName,
            partnerEmail: contractData?.investors[0]?.partnerEmail,
            partnerType: "Investor",
            splitPercentage: contractData?.investors[0]?.splitPercentage,
            amount:
              settlementAmount > 0
                ? (settlementAmount *
                    contractData?.investors[0]?.splitPercentage) /
                  100
                : 0,
            bankName:
              partnerData[contractData?.investors[0]?.partnerId]?.bankName,
            accountNumber:
              partnerData[contractData?.investors[0]?.partnerId]?.accountNumber,
            timezone,
            createdAtLocal,
            updatedAtLocal: createdAtLocal,
          });
        }
        if (contractData?.investors[1]?.partnerId) {
          settlementPartnerData.push({
            settlementId: savedSettlement?.id,
            partnerId: contractData?.investors[1]?.partnerId,
            partnerName: contractData?.investors[1]?.partnerName,
            partnerEmail: contractData?.investors[1]?.partnerEmail,
            partnerType: "Investor",
            splitPercentage: contractData?.investors[1]?.splitPercentage,
            amount:
              settlementAmount > 0
                ? (settlementAmount *
                    contractData?.investors[1]?.splitPercentage) /
                  100
                : 0,
            bankName:
              partnerData[contractData?.investors[1]?.partnerId]?.bankName,
            accountNumber:
              partnerData[contractData?.investors[1]?.partnerId]?.accountNumber,
            timezone,
            createdAtLocal,
            updatedAtLocal: createdAtLocal,
          });
        }
      }

      await SettlementPartnerRepository.save(settlementPartnerData);

      await ChargerRevenueRepository.update(
        { id: In(chargerRevenueIds) },
        {
          isSettlementGenerated: 1,
          settlementId: savedSettlement?.id,
        }
      );
    }
  }

  return res.status(200).json({
    message: "Settlement Generate successfully",
  });
};

const addSettlementPartner = async (req, res) => {
  try {
    const {
      settlementId,
      partnerId,
      partnerName,
      partnerEmail,
      partnerType,
      splitPercentage,
      amount,
      transferStatus,
      transferredBy,
      bankName,
      accountNumber,
      timezone,
      createdAt,
      updatedAt,
      createdAtLocal,
      updatedAtLocal,
    } = req.body;

    const settlementPartner = await SettlementPartnerRepository.create({
      settlementId,
      partnerId,
      partnerName,
      partnerEmail,
      partnerType,
      splitPercentage,
      amount,
      transferStatus,
      transferredBy,
      bankName,
      accountNumber,
      timezone,
      createdAt,
      updatedAt,
      createdAtLocal,
      updatedAtLocal,
    });

    const savedSettlementPartner = await SettlementPartnerRepository.save(
      settlementPartner
    );

    res.status(200).json(savedSettlementPartner);
  } catch (error) {
    console.error("Error adding settlement partner:", error);
    res.status(500).json({
      message: "Failed to add settlement partner",
      error: error.message,
    });
  }
};

const getSettlements = async (req, res) => {
  try {
    const { isPartner, isPartnerTeam } = req?.loggedInUserData;
    let { location, evseStationId, partnerType } = req?.query;

    if (req?.query?.filter) {
      try {
        const filter = JSON.parse(req?.query?.filter);

        if (!location && filter?.country) {
          location = filter?.country;
        }
        if (!evseStationId && filter?.chargingStationId) {
          evseStationId = filter?.chargingStationId;
        }
        if (!partnerType && filter?.partnerType) {
          partnerType = filter?.partnerType;
        }
      } catch (error) {}
    }

    let baseQuery = {};

    if (isPartner || isPartnerTeam) {
      const { contractIds } = req?.allowedIds;

      if (contractIds?.length == 0) {
        return res.status(200).json({
          list: [],
          currentPage: 1,
          totalPages: 0,
          totalCount: 0,
        });
      }

      baseQuery["contractId"] = {
        custom: true,
        value: `in("${contractIds.join('", "')}")`,
      };
    }

    if (location) {
      baseQuery["country"] = location;
    }

    if (evseStationId) {
      let tmpWhere = { evseStationId };
      if (isPartner || isPartnerTeam) {
        const { contractIds } = req?.allowedIds;
        tmpWhere["contractId"] = In(contractIds);
      }

      const contractEvseStations = await ContractEvseStationsRepository.find({
        where: tmpWhere,
      });
      if (contractEvseStations?.length == 0) {
        return res.status(200).json({
          list: [],
          currentPage: 1,
          totalPages: 0,
          totalCount: 0,
        });
      }

      const cIds = contractEvseStations.map(({ contractId }) => contractId);

      baseQuery["contractId"] = {
        custom: true,
        value: `in("${cIds.join('", "')}")`,
      };
    }

    if (partnerType == "Investor") {
      const settlementPartners = await SettlementPartnerRepository.find({
        where: { partnerType: "Investor" },
      });
      if (settlementPartners?.length == 0) {
        return res.status(200).json({
          list: [],
          currentPage: 1,
          totalPages: 0,
          totalCount: 0,
        });
      }

      const sIds = settlementPartners.map(({ settlementId }) => settlementId);

      baseQuery["id"] = {
        custom: true,
        value: `in("${sIds.join('", "')}")`,
      };
    }

    const order = { createdAt: "DESC" };
    const settlements = {
      entityName: "SettlementView",
      baseQuery,
      req,
    };
    settlements.order = order;

    const listResponse = await HandleMySqlList(settlements);

    if (listResponse.list.length > 0) {
      listResponse.list = listResponse.list.map((settlement) => {
        const partners = [];
        if (settlement.cpoName) {
          partners.push({
            id: settlement.cpoId,
            name: settlement.cpoName,
            role: "CPO",
            amount: settlement.cpoAmount,
            share: settlement.cpoSplitPercentage + "%",
            bankVerified: settlement.cpoBankVerificationStatus,
            contractApproved: settlement.cpoVerificationStatus === 1,
            bankName: settlement.cpoBankName,
            accountNumber: settlement.cpoBankAccountNumber,
            transferStatus: settlement.cpoTransferStatus,
          });
        }

        if (settlement.siteHostName) {
          partners.push({
            id: settlement.siteHostId,
            name: settlement.siteHostName,
            role: "SITE HOST",
            amount: settlement.siteHostAmount,
            share: settlement.siteHostSplitPercentage + "%",
            bankVerified: settlement.siteHostBankVerificationStatus,
            contractApproved: settlement.siteHostVerificationStatus === 1,
            bankName: settlement.siteHostBankName,
            accountNumber: settlement.siteHostBankAccountNumber,
            transferStatus: settlement.siteHostTransferStatus,
          });
        }

        if (settlement.investors) {
          settlement.investors.forEach((investor) => {
            partners.push({
              id: investor.partnerId,
              name: investor.partnerName,
              role: "INVESTOR",
              amount: investor.amount,
              share: investor.splitPercentage + "%",
              bankVerified: investor.bankVerificationStatus,
              contractApproved: investor.isVerified === 1,
              bankName: investor.bankName,
              accountNumber: investor.accountNumber,
              transferStatus: investor.transferStatus,
            });
          });
        }

        return {
          ...ObjectDAO(settlement),
          partners,
        };
      });
    }

    res.status(200).json(listResponse);
  } catch (error) {
    console.error("Error getting settlements:", error);
    res
      .status(500)
      .json({ message: "Failed to get settlements", error: error.message });
  }
};

const getSettlementById = async (req, res) => {
  try {
    const settlementId = req.params.settlementId;

    const settlement = await SettlementViewRepository.findOne({
      where: { id: settlementId },
    });

    if (!settlement) {
      return res.status(404).json({ message: "Settlement not found" });
    }

    // Get settlement partners
    const settlementPartners = await SettlementPartnerRepository.find({
      where: { settlementId: settlement.id },
      order: { createdAt: "ASC" },
    });

    const partners = [];
    if (settlement.cpoName) {
      partners.push({
        id: settlement.cpoId,
        name: settlement.cpoName,
        role: "CPO",
        amount: settlement.cpoAmount,
        share: settlement.cpoSplitPercentage + "%",
        bankVerified: settlement.cpoBankVerificationStatus,
        contractApproved: settlement.cpoVerificationStatus === 1,
        bankName: settlement.cpoBankName,
        accountNumber: settlement.cpoBankAccountNumber,
        transferStatus: settlement.cpoTransferStatus,
      });
    }

    if (settlement.siteHostName) {
      partners.push({
        id: settlement.siteHostId,
        name: settlement.siteHostName,
        role: "SITE HOST",
        amount: settlement.siteHostAmount,
        share: settlement.siteHostSplitPercentage + "%",
        bankVerified: settlement.siteHostBankVerificationStatus,
        contractApproved: settlement.siteHostVerificationStatus === 1,
        bankName: settlement.siteHostBankName,
        accountNumber: settlement.siteHostBankAccountNumber,
        transferStatus: settlement.siteHostTransferStatus,
      });
    }

    if (settlement.investors) {
      settlement.investors.forEach((investor) => {
        partners.push({
          id: investor.partnerId,
          name: investor.partnerName,
          role: "INVESTOR",
          amount: investor.amount,
          share: investor.splitPercentage + "%",
          bankVerified: investor.bankVerificationStatus,
          contractApproved: investor.isVerified === 1,
          bankName: investor.bankName,
          accountNumber: investor.accountNumber,
          transferStatus: investor.transferStatus,
        });
      });
    }

    const response = {
      ...ObjectDAO(settlement),
      partners: partners,
    };

    res.status(200).json(response);
  } catch (error) {
    console.error("Error getting settlement by ID:", error);
    res
      .status(500)
      .json({ message: "Failed to get settlement", error: error.message });
  }
};

const getSettlementSessions = async (req, res) => {
  try {
    const settlementId = req.params.settlementId;

    // Get settlement details
    const settlement = await SettlementRepository.findOne({
      where: { id: settlementId },
    });

    if (!settlement) {
      return res.status(404).json({ message: "Settlement not found" });
    }

    const chargerRevenueData = await ChargerRevenueRepository.find({
      where: { settlementId },
    });

    if (chargerRevenueData.length === 0) {
      return res.status(200).json([]);
    }

    const ocppTransactionIds = chargerRevenueData.map((cr) => {
      return cr.ocppTransactionId;
    });

    // Get sessions from ocpp_transactions
    const sessions = await OcppTransactionsRepository.find({
      where: { transactionUuid: In(ocppTransactionIds) },
      order: { createdAt: "DESC" },
    });

    res.status(200).json(sessions);
  } catch (error) {
    console.error("Error getting settlement sessions:", error);
    res.status(500).json({
      message: "Failed to get settlement sessions",
      error: error.message,
    });
  }
};

const getSettlementSessionOverview = async (req, res) => {
  try {
    const settlementId = req.params.settlementId;

    // Get settlement details
    const settlement = await SettlementRepository.findOne({
      where: { id: settlementId },
    });

    if (!settlement) {
      return res.status(404).json({ message: "Settlement not found" });
    }

    // Get partner count from contract_partners
    const contractPartners = await ContractPartnersRepository.find({
      where: { contractId: settlement.contractId, isDeleted: false },
    });
    const totalPartners = contractPartners.length;

    let totalSessions = 0;
    let totalRevenue = 0;

    const chargerRevenueData = await ChargerRevenueRepository.find({
      where: { settlementId },
    });

    if (chargerRevenueData.length > 0) {
      const ocppTransactionIds = chargerRevenueData.map((cr) => {
        return cr.ocppTransactionId;
      });

      // Get sessions from ocpp_transactions
      const sessions = await OcppTransactionsRepository.find({
        where: { transactionUuid: In(ocppTransactionIds) },
        order: { createdAt: "DESC" },
      });

      totalSessions = sessions.length;
      totalRevenue = sessions.reduce((sum, session) => {
        return sum + (parseFloat(session.netAmount) || 0);
      }, 0);
    }

    const response = {
      totalSessions,
      totalRevenue: parseFloat(totalRevenue).toFixed(2),
      totalPartners,
    };

    res.status(200).json(response);
  } catch (error) {
    console.error("Error getting settlement session overview:", error);
    res.status(500).json({
      message: "Failed to get settlement session overview",
      error: error.message,
    });
  }
};

const rejectSettlement = async (req, res) => {
  try {
    const settlementId = req.params.settlementId;

    const settlement = await SettlementRepository.findOne({
      where: { id: settlementId },
    });

    if (!settlement) {
      return res.status(404).json({ message: "Settlement not found" });
    }

    // Update settlement status to rejected
    await SettlementRepository.update(
      { id: settlementId },
      {
        status: SettlementStatuses.REJECTED,
        updatedAt: DateTime.utc().toJSDate(),
        updatedAtLocal: settlement.timezone
          ? formatDateString(DateTime.utc(), settlement.timezone)
          : null,
      }
    );

    res.status(200).json({ message: "Settlement rejected successfully" });
  } catch (error) {
    console.error("Error rejecting settlement:", error);
    res
      .status(500)
      .json({ message: "Failed to reject settlement", error: error.message });
  }
};

const updatePartnerTransferStatus = async (req, res) => {
  try {
    const settlementId = req.params.settlementId;
    const partnerId = req.params.partnerId;
    const updatedBy = req.loggedInUserData.userId;

    // Check if settlement exists
    const settlement = await SettlementRepository.findOne({
      where: { id: settlementId },
    });

    if (!settlement) {
      return res.status(404).json({ message: "Settlement not found" });
    }

    // Check if settlement partner exists
    const settlementPartner = await SettlementPartnerRepository.findOne({
      where: { settlementId: settlementId, partnerId: partnerId },
    });

    if (!settlementPartner) {
      return res.status(404).json({ message: "Settlement partner not found" });
    }

    // Update partner transfer status to completed
    await SettlementPartnerRepository.update(
      { id: settlementPartner.id },
      {
        transferStatus: TransferStatuses.COMPLETED,
        transferredBy: updatedBy,
        updatedAt: DateTime.utc().toJSDate(),
        updatedAtLocal: settlement.timezone
          ? formatDateString(DateTime.utc(), settlement.timezone)
          : null,
      }
    );

    await Promise.all([
      ChargerRevenueRepository.update(
        { settlementId, cpoId: settlementPartner?.partnerId },
        { isSettledForCpo: true }
      ),
      ChargerRevenueRepository.update(
        { settlementId, siteHostId: settlementPartner?.partnerId },
        { isSettledForSiteHost: true }
      ),
      ChargerRevenueRepository.update(
        { settlementId, investor1Id: settlementPartner?.partnerId },
        { isSettledForInvestor1: true }
      ),
      ChargerRevenueRepository.update(
        { settlementId, investor2Id: settlementPartner?.partnerId },
        { isSettledForInvestor2: true }
      ),
    ]);

    // Check if all partners are completed
    const allPartners = await SettlementPartnerRepository.find({
      where: { settlementId },
    });

    const allCompleted = allPartners.every(
      (partner) => partner.transferStatus === TransferStatuses.COMPLETED
    );

    if (allCompleted) {
      // Update main settlement status to settled
      //const invoicePdf = `settlement_${settlement.settlementId}_invoice.pdf`; // Generate actual PDF path

      await SettlementRepository.update(
        { id: settlementId },
        {
          status: SettlementStatuses.SETTLED,
        }
      );

      await ChargerRevenueRepository.update(
        { settlementId },
        {
          isSettled: true,
          isSettledForCpo: true,
          isSettledForSiteHost: true,
          isSettledForInvestor1: true,
          isSettledForInvestor2: true,
        }
      );
    } else {
      await SettlementRepository.update(
        { id: settlementId },
        {
          status: SettlementStatuses.PENDING,
        }
      );
    }

    res.status(200).json({
      message: "Partner transfer status updated successfully",
      settlementId,
      partnerId,
      allPartnersCompleted: allCompleted,
    });
  } catch (error) {
    console.error("Error updating partner transfer status:", error);
    res.status(500).json({
      message: "Failed to update partner transfer status",
      error: error.message,
    });
  }
};

const getDefaultResponseSettlementOverview = () => {
  return {
    totalAmountDepositedToChagnex: getTrendsData({
      currency: "$",
      isMoney: true,
      value: 0,
      valueTrends: 0,
    }),
    totalGatewayDeduction: getTrendsData({
      value: 0,
      valueTrends: 0,
    }),
    settlementCount: getTrendsData({
      value: 0,
      valueTrends: 0,
    }),
    totalAmountSettled: getTrendsData({
      currency: "$",
      isMoney: true,
      value: 0,
      valueTrends: 0,
    }),
  };
};

const getSettlementOverviewQuery = (sqlMatchConditionsRaw, settlementIds) => {
  const qry = ChargerRevenueRepository.createQueryBuilder(
    "chargerRevenue"
  ).where("chargerRevenue.isSettlementGenerated = :isSettlementGenerated", {
    isSettlementGenerated: 1,
  });

  qry.andWhere("chargerRevenue.settlementId IN (:...settlementIds)", {
    settlementIds,
  });

  // Filters applied here BEFORE subquery
  if (sqlMatchConditionsRaw?.evseStationId?.length) {
    qry.andWhere("chargerRevenue.evseStationId IN (:...evseStationIds)", {
      evseStationIds: sqlMatchConditionsRaw.evseStationId,
    });
  }
  if (sqlMatchConditionsRaw?.chargeBoxId?.length) {
    qry.andWhere("chargerRevenue.chargeBoxId IN (:...chargeBoxIds)", {
      chargeBoxIds: sqlMatchConditionsRaw.chargeBoxId,
    });
  }
  if (sqlMatchConditionsRaw?.contractId?.length) {
    qry.andWhere("chargerRevenue.contractId IN (:...contractId)", {
      contractId: sqlMatchConditionsRaw.contractId,
    });
  }
  if (sqlMatchConditionsRaw?.location) {
    qry.andWhere("chargerRevenue.country = :location", {
      location: sqlMatchConditionsRaw.location,
    });
  }

  return qry;
};

const getSettlementOverviewData = async (
  sqlMatchConditionsRaw,
  settlementIds
) => {
  if (settlementIds?.length == 0) {
    return {
      totalSettled: 0,
      totalAmount: 0,
      settlementCount: 0,
    };
  }

  const [
    totalData,
    cpoAmount,
    siteHostAmount,
    investor1Amount,
    investor2Amount,
  ] = await Promise.all([
    getSettlementOverviewQuery(sqlMatchConditionsRaw, settlementIds)
      .select([
        "SUM(chargerRevenue.totalAmount) as totalAmount",
        "SUM(chargerRevenue.cpoAmount) as totalCpoAmount",
        "SUM(chargerRevenue.siteHostAmount) as totalSiteHostAmount",
        "SUM(chargerRevenue.investor1Amount) as totalInvestor1Amount",
        "SUM(chargerRevenue.investor2Amount) as totalInvestor2Amount",
        "COUNT(DISTINCT(chargerRevenue.settlementId)) as settlementCount",
      ])
      .getRawOne(),
    getSettlementOverviewQuery(sqlMatchConditionsRaw, settlementIds)
      .select(["SUM(chargerRevenue.cpoAmount) as totalAmount"])
      .andWhere("chargerRevenue.isSettledForCpo = :isSettledForCpo", {
        isSettledForCpo: 1,
      })
      .getRawOne(),
    getSettlementOverviewQuery(sqlMatchConditionsRaw, settlementIds)
      .select(["SUM(chargerRevenue.siteHostAmount) as totalAmount"])
      .andWhere("chargerRevenue.isSettledForSiteHost = :isSettledForSiteHost", {
        isSettledForSiteHost: 1,
      })
      .getRawOne(),
    getSettlementOverviewQuery(sqlMatchConditionsRaw, settlementIds)
      .select(["SUM(chargerRevenue.investor1Amount) as totalAmount"])
      .andWhere(
        "chargerRevenue.isSettledForInvestor1 = :isSettledForInvestor1",
        {
          isSettledForInvestor1: 1,
        }
      )
      .getRawOne(),
    getSettlementOverviewQuery(sqlMatchConditionsRaw, settlementIds)
      .select(["SUM(chargerRevenue.investor2Amount) as totalAmount"])
      .andWhere(
        "chargerRevenue.isSettledForInvestor2 = :isSettledForInvestor2",
        {
          isSettledForInvestor2: 1,
        }
      )
      .getRawOne(),
  ]);

  let totalSettled = Number(cpoAmount?.totalAmount || 0);
  totalSettled += Number(siteHostAmount?.totalAmount || 0);
  totalSettled += Number(investor1Amount?.totalAmount || 0);
  totalSettled += Number(investor2Amount?.totalAmount || 0);

  let totalSettledCpo = Number(cpoAmount?.totalAmount || 0);
  let totalSettledSiteHost = Number(siteHostAmount?.totalAmount || 0);
  let totalSettledInvestor = Number(investor1Amount?.totalAmount || 0);
  totalSettledInvestor += Number(investor2Amount?.totalAmount || 0);

  let totalAmountCpo = Number(totalData?.totalCpoAmount || 0);
  let totalAmountSiteHost = Number(totalData?.totalSiteHostAmount || 0);
  let totalAmountInvestor = Number(totalData?.totalInvestor1Amount || 0);
  totalAmountInvestor += Number(totalData?.totalInvestor2Amount || 0);

  return {
    totalSettled,
    totalSettledCpo,
    totalSettledSiteHost,
    totalSettledInvestor,
    totalAmount: Number(totalData?.totalAmount || 0),
    totalAmountCpo,
    totalAmountSiteHost,
    totalAmountInvestor,
    settlementCount: Number(totalData?.settlementCount || 0),
  };
};

const getSettlementOverview = async (req, res) => {
  try {
    const {
      returnDefaultResponse,
      sqlMatchConditionsRaw,
      rangeRaw,
      rangeRawTrend,
    } = req.analyticsFilters;
    const { isPartner, isPartnerTeam } = req?.loggedInUserData;

    let { location, evseStationId, partnerType } = req?.query;

    if (req?.query?.filter) {
      try {
        const filter = JSON.parse(req?.query?.filter);

        if (!location && filter?.country) {
          location = filter?.country;
        }
        if (!evseStationId && filter?.chargingStationId) {
          evseStationId = filter?.chargingStationId;
        }
        if (!partnerType && filter?.partnerType) {
          partnerType = filter?.partnerType;
        }
      } catch (error) {}
    }

    let baseQuery = {};

    if (isPartner || isPartnerTeam) {
      const { contractIds } = req?.allowedIds;

      if (contractIds?.length == 0) {
        return res.status(200).json({
          list: [],
          currentPage: 1,
          totalPages: 0,
          totalCount: 0,
        });
      }

      baseQuery["contractId"] = In(contractIds);
    }

    if (location) {
      baseQuery["country"] = location;
    }

    if (evseStationId) {
      let tmpWhere = { evseStationId };
      if (isPartner || isPartnerTeam) {
        const { contractIds } = req?.allowedIds;
        tmpWhere["contractId"] = In(contractIds);
      }

      const contractEvseStations = await ContractEvseStationsRepository.find({
        where: tmpWhere,
      });
      if (contractEvseStations?.length == 0) {
        return res.status(200).json({
          list: [],
          currentPage: 1,
          totalPages: 0,
          totalCount: 0,
        });
      }

      const cIds = contractEvseStations.map(({ contractId }) => contractId);
      baseQuery["contractId"] = In(cIds);
    }

    if (partnerType == "Investor") {
      const settlementPartners = await SettlementPartnerRepository.find({
        where: { partnerType: "Investor" },
      });
      if (settlementPartners?.length == 0) {
        return res.status(200).json({
          list: [],
          currentPage: 1,
          totalPages: 0,
          totalCount: 0,
        });
      }

      const sIds = settlementPartners.map(({ settlementId }) => settlementId);
      baseQuery["id"] = In(sIds);
    }

    const defaultResponse = getDefaultResponseSettlementOverview();

    if (returnDefaultResponse === true) {
      return res.status(200).json(defaultResponse);
    }

    const [settlements, settlementsTrends] = await Promise.all([
      SettlementRepository.find({
        where: {
          createdAt: Between(rangeRaw.start, rangeRaw.end),
          ...baseQuery,
        },
      }),
      SettlementRepository.find({
        where: {
          createdAt: Between(rangeRawTrend.start, rangeRawTrend.end),
          ...baseQuery,
        },
      }),
    ]);

    const settlementIds = settlements.map(({ id }) => id);
    const settlementIdsTrends = settlementsTrends.map(({ id }) => id);

    const [allAnalytics, allAnalyticsTrends] = await Promise.all([
      getSettlementOverviewData(sqlMatchConditionsRaw, settlementIds),
      getSettlementOverviewData(sqlMatchConditionsRaw, settlementIdsTrends),
    ]);

    let {
      totalSettled = 0,
      totalSettledCpo = 0,
      totalSettledSiteHost = 0,
      totalSettledInvestor = 0,
      totalAmount = 0,
      totalAmountCpo = 0,
      totalAmountSiteHost = 0,
      totalAmountInvestor = 0,
      settlementCount = 0,
    } = allAnalytics;
    let {
      totalSettled: totalSettledTrends = 0,
      totalSettledCpo: totalSettledCpoTrends = 0,
      totalSettledSiteHost: totalSettledSiteHostTrends = 0,
      totalSettledInvestor: totalSettledInvestorTrends = 0,
      totalAmount: totalAmountTrends = 0,
      totalAmountCpo: totalAmountCpoTrends = 0,
      totalAmountSiteHost: totalAmountSiteHostTrends = 0,
      totalAmountInvestor: totalAmountInvestorTrends = 0,
      settlementCount: settlementCountTrends = 0,
    } = allAnalyticsTrends;

    if (!partnerType) {
      defaultResponse["totalAmountSettled"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalSettled,
        valueTrends: totalSettledTrends,
      });

      defaultResponse["totalAmountDepositedToChagnex"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalAmount,
        valueTrends: totalAmountTrends,
      });
    } else if (partnerType == "Cpo") {
      defaultResponse["totalAmountSettled"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalSettledCpo,
        valueTrends: totalSettledCpoTrends,
      });

      defaultResponse["totalAmountDepositedToChagnex"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalAmountCpo,
        valueTrends: totalAmountCpoTrends,
      });
    } else if (partnerType == "Site Host") {
      defaultResponse["totalAmountSettled"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalSettledSiteHost,
        valueTrends: totalSettledSiteHostTrends,
      });

      defaultResponse["totalAmountDepositedToChagnex"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalAmountSiteHost,
        valueTrends: totalAmountSiteHostTrends,
      });
    } else if (partnerType == "Investor") {
      defaultResponse["totalAmountSettled"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalSettledInvestor,
        valueTrends: totalSettledInvestorTrends,
      });

      defaultResponse["totalAmountDepositedToChagnex"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalAmountInvestor,
        valueTrends: totalAmountInvestorTrends,
      });
    } else {
      defaultResponse["totalAmountSettled"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalSettled,
        valueTrends: totalSettledTrends,
      });

      defaultResponse["totalAmountDepositedToChagnex"] = getTrendsData({
        currency: "$",
        isMoney: true,
        value: totalAmount,
        valueTrends: totalAmountTrends,
      });
    }

    defaultResponse["settlementCount"] = getTrendsData({
      value: settlementCount,
      valueTrends: settlementCountTrends,
    });

    defaultResponse["totalGatewayDeduction"] = getTrendsData({
      value: 0,
      valueTrends: 0,
    });

    return res.status(200).json(defaultResponse);
  } catch (error) {
    console.error("Error getting settlement overview:", error);
    res.status(500).json({
      message: "Failed to get settlement overview",
      error: error.message,
    });
  }
};

module.exports = {
  addSettlement,
  addSettlementPartner,
  getSettlements,
  getSettlementById,
  getSettlementSessions,
  getSettlementSessionOverview,
  rejectSettlement,
  updatePartnerTransferStatus,
  getSettlementOverview,
  generateSettlement,
};
